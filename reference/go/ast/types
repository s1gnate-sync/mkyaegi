type ArrayType struct {
	Lbrack token.Pos // position of "["
	Len    Expr      // Ellipsis node for [...]T array types, nil for slice types
	Elt    Expr      // element type
}
func (x *ArrayType) End() token.Pos
func (x *ArrayType) Pos() token.Pos
type AssignStmt struct {
	Lhs    []Expr
	TokPos token.Pos   // position of Tok
	Tok    token.Token // assignment token, DEFINE
	Rhs    []Expr
}
func (s *AssignStmt) End() token.Pos
func (s *AssignStmt) Pos() token.Pos
type BadDecl struct {
	From, To token.Pos // position range of bad declaration
}
func (d *BadDecl) End() token.Pos
func (d *BadDecl) Pos() token.Pos
type BadExpr struct {
	From, To token.Pos // position range of bad expression
}
func (x *BadExpr) End() token.Pos
func (x *BadExpr) Pos() token.Pos
type BadStmt struct {
	From, To token.Pos // position range of bad statement
}
func (s *BadStmt) End() token.Pos
func (s *BadStmt) Pos() token.Pos
type BasicLit struct {
	ValuePos token.Pos   // literal position
	Kind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING
	Value    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\x7f', "foo" or `\m\n\o`
}
func (x *BasicLit) End() token.Pos
func (x *BasicLit) Pos() token.Pos
type BinaryExpr struct {
	X     Expr        // left operand
	OpPos token.Pos   // position of Op
	Op    token.Token // operator
	Y     Expr        // right operand
}
func (x *BinaryExpr) End() token.Pos
func (x *BinaryExpr) Pos() token.Pos
type BlockStmt struct {
	Lbrace token.Pos // position of "{"
	List   []Stmt
	Rbrace token.Pos // position of "}", if any (may be absent due to syntax error)
}
func (s *BlockStmt) End() token.Pos
func (s *BlockStmt) Pos() token.Pos
type BranchStmt struct {
	TokPos token.Pos   // position of Tok
	Tok    token.Token // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)
	Label  *Ident      // label name; or nil
}
func (s *BranchStmt) End() token.Pos
func (s *BranchStmt) Pos() token.Pos
type CallExpr struct {
	Fun      Expr      // function expression
	Lparen   token.Pos // position of "("
	Args     []Expr    // function arguments; or nil
	Ellipsis token.Pos // position of "..." (token.NoPos if there is no "...")
	Rparen   token.Pos // position of ")"
}
func (x *CallExpr) End() token.Pos
func (x *CallExpr) Pos() token.Pos
type CaseClause struct {
	Case  token.Pos // position of "case" or "default" keyword
	List  []Expr    // list of expressions or types; nil means default case
	Colon token.Pos // position of ":"
	Body  []Stmt    // statement list; or nil
}
func (s *CaseClause) End() token.Pos
func (s *CaseClause) Pos() token.Pos
type ChanDir int
const (
	SEND ChanDir = 1 << iota
	RECV
)
type ChanType struct {
	Begin token.Pos // position of "chan" keyword or "<-" (whichever comes first)
	Arrow token.Pos // position of "<-" (token.NoPos if there is no "<-")
	Dir   ChanDir   // channel direction
	Value Expr      // value type
}
func (x *ChanType) End() token.Pos
func (x *ChanType) Pos() token.Pos
type CommClause struct {
	Case  token.Pos // position of "case" or "default" keyword
	Comm  Stmt      // send or receive statement; nil means default case
	Colon token.Pos // position of ":"
	Body  []Stmt    // statement list; or nil
}
func (s *CommClause) End() token.Pos
func (s *CommClause) Pos() token.Pos
type Comment struct {
	Slash token.Pos // position of "/" starting the comment
	Text  string    // comment text (excluding '\n' for //-style comments)
}
func (c *Comment) End() token.Pos
func (c *Comment) Pos() token.Pos
type CommentGroup struct {
	List []*Comment // len(List) > 0
}
func (g *CommentGroup) End() token.Pos
func (g *CommentGroup) Pos() token.Pos
func (g *CommentGroup) Text() string
type CommentMap map[Node][]*CommentGroup
func NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap
func (cmap CommentMap) Comments() []*CommentGroup
func (cmap CommentMap) Filter(node Node) CommentMap
func (cmap CommentMap) String() string
func (cmap CommentMap) Update(old, new Node) Node
type CompositeLit struct {
	Type       Expr      // literal type; or nil
	Lbrace     token.Pos // position of "{"
	Elts       []Expr    // list of composite elements; or nil
	Rbrace     token.Pos // position of "}"
	Incomplete bool      // true if (source) expressions are missing in the Elts list
}
func (x *CompositeLit) End() token.Pos
func (x *CompositeLit) Pos() token.Pos
type Decl interface {
	Node
	// Has unexported methods.
}
type DeclStmt struct {
	Decl Decl // *GenDecl with CONST, TYPE, or VAR token
}
func (s *DeclStmt) End() token.Pos
func (s *DeclStmt) Pos() token.Pos
type DeferStmt struct {
	Defer token.Pos // position of "defer" keyword
	Call  *CallExpr
}
func (s *DeferStmt) End() token.Pos
func (s *DeferStmt) Pos() token.Pos
type Ellipsis struct {
	Ellipsis token.Pos // position of "..."
	Elt      Expr      // ellipsis element type (parameter lists only); or nil
}
func (x *Ellipsis) End() token.Pos
func (x *Ellipsis) Pos() token.Pos
type EmptyStmt struct {
	Semicolon token.Pos // position of following ";"
	Implicit  bool      // if set, ";" was omitted in the source
}
func (s *EmptyStmt) End() token.Pos
func (s *EmptyStmt) Pos() token.Pos
type Expr interface {
	Node
	// Has unexported methods.
}
func Unparen(e Expr) Expr
type ExprStmt struct {
	X Expr // expression
}
func (s *ExprStmt) End() token.Pos
func (s *ExprStmt) Pos() token.Pos
type Field struct {
	Doc     *CommentGroup // associated documentation; or nil
	Names   []*Ident      // field/method/(type) parameter names; or nil
	Type    Expr          // field/method/parameter type; or nil
	Tag     *BasicLit     // field tag; or nil
	Comment *CommentGroup // line comments; or nil
}
func (f *Field) End() token.Pos
func (f *Field) Pos() token.Pos
type FieldFilter func(name string, value reflect.Value) bool
type FieldList struct {
	Opening token.Pos // position of opening parenthesis/brace/bracket, if any
	List    []*Field  // field list; or nil
	Closing token.Pos // position of closing parenthesis/brace/bracket, if any
}
func (f *FieldList) End() token.Pos
func (f *FieldList) NumFields() int
func (f *FieldList) Pos() token.Pos
type File struct {
	Doc     *CommentGroup // associated documentation; or nil
	Package token.Pos     // position of "package" keyword
	Name    *Ident        // package name
	Decls   []Decl        // top-level declarations; or nil
	FileStart, FileEnd token.Pos       // start and end of entire file
	Scope              *Scope          // package scope (this file only). Deprecated: see Object
	Imports            []*ImportSpec   // imports in this file
	Unresolved         []*Ident        // unresolved identifiers in this file. Deprecated: see Object
	Comments           []*CommentGroup // list of all comments in the source file
	GoVersion          string          // minimum Go version required by //go:build or // +build directives
}
[#18593]: https://go.dev/issue/18593
[#20744]: https://go.dev/issue/20744
func MergePackageFiles(pkg *Package, mode MergeMode) *File
func (f *File) End() token.Pos
func (f *File) Pos() token.Pos
type Filter func(string) bool
type ForStmt struct {
	For  token.Pos // position of "for" keyword
	Init Stmt      // initialization statement; or nil
	Cond Expr      // condition; or nil
	Post Stmt      // post iteration statement; or nil
	Body *BlockStmt
}
func (s *ForStmt) End() token.Pos
func (s *ForStmt) Pos() token.Pos
type FuncDecl struct {
	Doc  *CommentGroup // associated documentation; or nil
	Recv *FieldList    // receiver (methods); or nil (functions)
	Name *Ident        // function/method name
	Type *FuncType     // function signature: type and value parameters, results, and position of "func" keyword
	Body *BlockStmt    // function body; or nil for external (non-Go) function
}
func (d *FuncDecl) End() token.Pos
func (d *FuncDecl) Pos() token.Pos
type FuncLit struct {
	Type *FuncType  // function type
	Body *BlockStmt // function body
}
func (x *FuncLit) End() token.Pos
func (x *FuncLit) Pos() token.Pos
type FuncType struct {
	Func       token.Pos  // position of "func" keyword (token.NoPos if there is no "func")
	TypeParams *FieldList // type parameters; or nil
	Params     *FieldList // (incoming) parameters; non-nil
	Results    *FieldList // (outgoing) results; or nil
}
func (x *FuncType) End() token.Pos
func (x *FuncType) Pos() token.Pos
type GenDecl struct {
	Doc    *CommentGroup // associated documentation; or nil
	TokPos token.Pos     // position of Tok
	Tok    token.Token   // IMPORT, CONST, TYPE, or VAR
	Lparen token.Pos     // position of '(', if any
	Specs  []Spec
	Rparen token.Pos // position of ')', if any
}
func (d *GenDecl) End() token.Pos
func (d *GenDecl) Pos() token.Pos
type GoStmt struct {
	Go   token.Pos // position of "go" keyword
	Call *CallExpr
}
func (s *GoStmt) End() token.Pos
func (s *GoStmt) Pos() token.Pos
type Ident struct {
	NamePos token.Pos // identifier position
	Name    string    // identifier name
	Obj     *Object   // denoted object, or nil. Deprecated: see Object.
}
func NewIdent(name string) *Ident
func (x *Ident) End() token.Pos
func (id *Ident) IsExported() bool
func (x *Ident) Pos() token.Pos
func (id *Ident) String() string
type IfStmt struct {
	If   token.Pos // position of "if" keyword
	Init Stmt      // initialization statement; or nil
	Cond Expr      // condition
	Body *BlockStmt
	Else Stmt // else branch; or nil
}
func (s *IfStmt) End() token.Pos
func (s *IfStmt) Pos() token.Pos
type ImportSpec struct {
	Doc     *CommentGroup // associated documentation; or nil
	Name    *Ident        // local package name (including "."); or nil
	Path    *BasicLit     // import path
	Comment *CommentGroup // line comments; or nil
	EndPos  token.Pos     // end of spec (overrides Path.Pos if nonzero)
}
func (s *ImportSpec) End() token.Pos
func (s *ImportSpec) Pos() token.Pos
type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)
type IncDecStmt struct {
	X      Expr
	TokPos token.Pos   // position of Tok
	Tok    token.Token // INC or DEC
}
func (s *IncDecStmt) End() token.Pos
func (s *IncDecStmt) Pos() token.Pos
type IndexExpr struct {
	X      Expr      // expression
	Lbrack token.Pos // position of "["
	Index  Expr      // index expression
	Rbrack token.Pos // position of "]"
}
func (x *IndexExpr) End() token.Pos
func (x *IndexExpr) Pos() token.Pos
type IndexListExpr struct {
	X       Expr      // expression
	Lbrack  token.Pos // position of "["
	Indices []Expr    // index expressions
	Rbrack  token.Pos // position of "]"
}
func (x *IndexListExpr) End() token.Pos
func (x *IndexListExpr) Pos() token.Pos
type InterfaceType struct {
	Interface  token.Pos  // position of "interface" keyword
	Methods    *FieldList // list of embedded interfaces, methods, or types
	Incomplete bool       // true if (source) methods or types are missing in the Methods list
}
func (x *InterfaceType) End() token.Pos
func (x *InterfaceType) Pos() token.Pos
type KeyValueExpr struct {
	Key   Expr
	Colon token.Pos // position of ":"
	Value Expr
}
func (x *KeyValueExpr) End() token.Pos
func (x *KeyValueExpr) Pos() token.Pos
type LabeledStmt struct {
	Label *Ident
	Colon token.Pos // position of ":"
	Stmt  Stmt
}
func (s *LabeledStmt) End() token.Pos
func (s *LabeledStmt) Pos() token.Pos
type MapType struct {
	Map   token.Pos // position of "map" keyword
	Key   Expr
	Value Expr
}
func (x *MapType) End() token.Pos
func (x *MapType) Pos() token.Pos
type MergeMode uint
const (
	// If set, duplicate function declarations are excluded.
	FilterFuncDuplicates MergeMode = 1 << iota
	// If set, comments that are not associated with a specific
	// AST node (as Doc or Comment) are excluded.
	FilterUnassociatedComments
	// If set, duplicate import declarations are excluded.
	FilterImportDuplicates
)
type Node interface {
	Pos() token.Pos // position of first character belonging to the node
	End() token.Pos // position of first character immediately after the node
}
type ObjKind int
const (
	Bad ObjKind = iota // for error handling
	Pkg                // package
	Con                // constant
	Typ                // type
	Var                // variable
	Fun                // function or method
	Lbl                // label
)
func (kind ObjKind) String() string
type Object struct {
	Kind ObjKind
	Name string // declared name
	Decl any    // corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil
	Data any    // object-specific data; or nil
	Type any    // placeholder for type information; may be nil
}
func NewObj(kind ObjKind, name string) *Object
func (obj *Object) Pos() token.Pos
type Package struct {
	Name    string             // package name
	Scope   *Scope             // package scope across all files
	Imports map[string]*Object // map of package id -> package object
	Files   map[string]*File   // Go source files by filename
}
func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)
func (p *Package) End() token.Pos
func (p *Package) Pos() token.Pos
type ParenExpr struct {
	Lparen token.Pos // position of "("
	X      Expr      // parenthesized expression
	Rparen token.Pos // position of ")"
}
func (x *ParenExpr) End() token.Pos
func (x *ParenExpr) Pos() token.Pos
type RangeStmt struct {
	For        token.Pos   // position of "for" keyword
	Key, Value Expr        // Key, Value may be nil
	TokPos     token.Pos   // position of Tok; invalid if Key == nil
	Tok        token.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE
	Range      token.Pos   // position of "range" keyword
	X          Expr        // value to range over
	Body       *BlockStmt
}
func (s *RangeStmt) End() token.Pos
func (s *RangeStmt) Pos() token.Pos
type ReturnStmt struct {
	Return  token.Pos // position of "return" keyword
	Results []Expr    // result expressions; or nil
}
func (s *ReturnStmt) End() token.Pos
func (s *ReturnStmt) Pos() token.Pos
type Scope struct {
	Outer   *Scope
	Objects map[string]*Object
}
func NewScope(outer *Scope) *Scope
func (s *Scope) Insert(obj *Object) (alt *Object)
func (s *Scope) Lookup(name string) *Object
func (s *Scope) String() string
type SelectStmt struct {
	Select token.Pos  // position of "select" keyword
	Body   *BlockStmt // CommClauses only
}
func (s *SelectStmt) End() token.Pos
func (s *SelectStmt) Pos() token.Pos
type SelectorExpr struct {
	X   Expr   // expression
	Sel *Ident // field selector
}
func (x *SelectorExpr) End() token.Pos
func (x *SelectorExpr) Pos() token.Pos
type SendStmt struct {
	Chan  Expr
	Arrow token.Pos // position of "<-"
	Value Expr
}
func (s *SendStmt) End() token.Pos
func (s *SendStmt) Pos() token.Pos
type SliceExpr struct {
	X      Expr      // expression
	Lbrack token.Pos // position of "["
	Low    Expr      // begin of slice range; or nil
	High   Expr      // end of slice range; or nil
	Max    Expr      // maximum capacity of slice; or nil
	Slice3 bool      // true if 3-index slice (2 colons present)
	Rbrack token.Pos // position of "]"
}
func (x *SliceExpr) End() token.Pos
func (x *SliceExpr) Pos() token.Pos
type Spec interface {
	Node
	// Has unexported methods.
}
type StarExpr struct {
	Star token.Pos // position of "*"
	X    Expr      // operand
}
func (x *StarExpr) End() token.Pos
func (x *StarExpr) Pos() token.Pos
type Stmt interface {
	Node
	// Has unexported methods.
}
type StructType struct {
	Struct     token.Pos  // position of "struct" keyword
	Fields     *FieldList // list of field declarations
	Incomplete bool       // true if (source) fields are missing in the Fields list
}
func (x *StructType) End() token.Pos
func (x *StructType) Pos() token.Pos
type SwitchStmt struct {
	Switch token.Pos  // position of "switch" keyword
	Init   Stmt       // initialization statement; or nil
	Tag    Expr       // tag expression; or nil
	Body   *BlockStmt // CaseClauses only
}
func (s *SwitchStmt) End() token.Pos
func (s *SwitchStmt) Pos() token.Pos
type TypeAssertExpr struct {
	X      Expr      // expression
	Lparen token.Pos // position of "("
	Type   Expr      // asserted type; nil means type switch X.(type)
	Rparen token.Pos // position of ")"
}
func (x *TypeAssertExpr) End() token.Pos
func (x *TypeAssertExpr) Pos() token.Pos
type TypeSpec struct {
	Doc        *CommentGroup // associated documentation; or nil
	Name       *Ident        // type name
	TypeParams *FieldList    // type parameters; or nil
	Assign     token.Pos     // position of '=', if any
	Type       Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes
	Comment    *CommentGroup // line comments; or nil
}
func (s *TypeSpec) End() token.Pos
func (s *TypeSpec) Pos() token.Pos
type TypeSwitchStmt struct {
	Switch token.Pos  // position of "switch" keyword
	Init   Stmt       // initialization statement; or nil
	Assign Stmt       // x := y.(type) or y.(type)
	Body   *BlockStmt // CaseClauses only
}
func (s *TypeSwitchStmt) End() token.Pos
func (s *TypeSwitchStmt) Pos() token.Pos
type UnaryExpr struct {
	OpPos token.Pos   // position of Op
	Op    token.Token // operator
	X     Expr        // operand
}
func (x *UnaryExpr) End() token.Pos
func (x *UnaryExpr) Pos() token.Pos
type ValueSpec struct {
	Doc     *CommentGroup // associated documentation; or nil
	Names   []*Ident      // value names (len(Names) > 0)
	Type    Expr          // value type; or nil
	Values  []Expr        // initial values; or nil
	Comment *CommentGroup // line comments; or nil
}
func (s *ValueSpec) End() token.Pos
func (s *ValueSpec) Pos() token.Pos
type Visitor interface {
	Visit(node Node) (w Visitor)
