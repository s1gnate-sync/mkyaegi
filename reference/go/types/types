type Alias struct {
	// Has unexported fields.
}
func NewAlias(obj *TypeName, rhs Type) *Alias
func (a *Alias) Obj() *TypeName
func (a *Alias) Origin() *Alias
func (a *Alias) Rhs() Type
func (a *Alias) SetTypeParams(tparams []*TypeParam)
func (a *Alias) String() string
func (a *Alias) TypeArgs() *TypeList
func (a *Alias) TypeParams() *TypeParamList
func (a *Alias) Underlying() Type
[underlying type]: https://go.dev/ref/spec#Underlying_types.
type ArgumentError struct {
	Index int
	Err   error
}
func (e *ArgumentError) Error() string
func (e *ArgumentError) Unwrap() error
type Array struct {
	// Has unexported fields.
}
func NewArray(elem Type, len int64) *Array
func (a *Array) Elem() Type
func (a *Array) Len() int64
func (a *Array) String() string
func (a *Array) Underlying() Type
type Basic struct {
	// Has unexported fields.
}
func (b *Basic) Info() BasicInfo
func (b *Basic) Kind() BasicKind
func (b *Basic) Name() string
func (b *Basic) String() string
func (b *Basic) Underlying() Type
type BasicInfo int
const (
	IsBoolean BasicInfo = 1 << iota
	IsInteger
	IsUnsigned
	IsFloat
	IsComplex
	IsString
	IsUntyped
	IsOrdered   = IsInteger | IsFloat | IsString
	IsNumeric   = IsInteger | IsFloat | IsComplex
	IsConstType = IsBoolean | IsNumeric | IsString
)
type BasicKind int
const (
	Invalid BasicKind = iota // type is invalid
	// predeclared types
	Bool
	Int
	Int8
	Int16
	Int32
	Int64
	Uint
	Uint8
	Uint16
	Uint32
	Uint64
	Uintptr
	Float32
	Float64
	Complex64
	Complex128
	String
	UnsafePointer
	// types for untyped values
	UntypedBool
	UntypedInt
	UntypedRune
	UntypedFloat
	UntypedComplex
	UntypedString
	UntypedNil
	// aliases
	Byte = Uint8
	Rune = Int32
)
type Builtin struct {
	// Has unexported fields.
}
func (obj *Builtin) Exported() bool
func (obj *Builtin) Id() string
func (obj *Builtin) Name() string
func (obj *Builtin) Parent() *Scope
func (obj *Builtin) Pkg() *Package
func (obj *Builtin) Pos() token.Pos
func (obj *Builtin) String() string
func (obj *Builtin) Type() Type
type Chan struct {
	// Has unexported fields.
}
func NewChan(dir ChanDir, elem Type) *Chan
func (c *Chan) Dir() ChanDir
func (c *Chan) Elem() Type
func (c *Chan) String() string
func (c *Chan) Underlying() Type
type ChanDir int
const (
	SendRecv ChanDir = iota
	SendOnly
	RecvOnly
)
type Checker struct {
	*Info
	// Has unexported fields.
}
func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker
func (check *Checker) Files(files []*ast.File) (err error)
type Config struct {
	// Context is the context used for resolving global identifiers. If nil, the
	// type checker will initialize this field with a newly created context.
	Context *Context
	// GoVersion describes the accepted Go language version. The string must
	// start with a prefix of the form "go%d.%d" (e.g. "go1.20", "go1.21rc1", or
	// "go1.21.0") or it must be empty; an empty string disables Go language
	// version checks. If the format is invalid, invoking the type checker will
	// result in an error.
	GoVersion string
	// If IgnoreFuncBodies is set, function bodies are not
	// type-checked.
	IgnoreFuncBodies bool
	// If FakeImportC is set, `import "C"` (for packages requiring Cgo)
	// declares an empty "C" package and errors are omitted for qualified
	// identifiers referring to package C (which won't find an object).
	// This feature is intended for the standard library cmd/api tool.
	//
	// Caution: Effects may be unpredictable due to follow-on errors.
	//          Do not use casually!
	FakeImportC bool
	// If Error != nil, it is called with each error found
	// during type checking; err has dynamic type Error.
	// Secondary errors (for instance, to enumerate all types
	// involved in an invalid recursive type declaration) have
	// error strings that start with a '\t' character.
	// If Error == nil, type-checking stops with the first
	// error found.
	Error func(err error)
	// An importer is used to import packages referred to from
	// import declarations.
	// If the installed importer implements ImporterFrom, the type
	// checker calls ImportFrom instead of Import.
	// The type checker reports an error if an importer is needed
	// but none was installed.
	Importer Importer
	// If Sizes != nil, it provides the sizing functions for package unsafe.
	// Otherwise SizesFor("gc", "amd64") is used instead.
	Sizes Sizes
	// If DisableUnusedImportCheck is set, packages are not checked
	// for unused imports.
	DisableUnusedImportCheck bool
	// Has unexported fields.
}
func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)
type Const struct {
	// Has unexported fields.
}
func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const
func (obj *Const) Exported() bool
func (obj *Const) Id() string
func (obj *Const) Name() string
func (obj *Const) Parent() *Scope
func (obj *Const) Pkg() *Package
func (obj *Const) Pos() token.Pos
func (obj *Const) String() string
func (obj *Const) Type() Type
func (obj *Const) Val() constant.Value
type Context struct {
	// Has unexported fields.
}
func NewContext() *Context
type Error struct {
	Fset *token.FileSet // file set for interpretation of Pos
	Pos  token.Pos      // error position
	Msg  string         // error message
	Soft bool           // if set, error is "soft"
	// Has unexported fields.
}
func (err Error) Error() string
type Func struct {
	// Has unexported fields.
}
func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)
func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func
func (obj *Func) Exported() bool
func (obj *Func) FullName() string
func (obj *Func) Id() string
func (obj *Func) Name() string
func (obj *Func) Origin() *Func
func (obj *Func) Parent() *Scope
func (obj *Func) Pkg() *Package
func (obj *Func) Pos() token.Pos
func (obj *Func) Scope() *Scope
func (obj *Func) Signature() *Signature
func (obj *Func) String() string
func (obj *Func) Type() Type
type ImportMode int
type Importer interface {
	// Import returns the imported package for the given import path.
	// The semantics is like for ImporterFrom.ImportFrom except that
	// dir and mode are ignored (since they are not present).
	Import(path string) (*Package, error)
}
type ImporterFrom interface {
	// Importer is present for backward-compatibility. Calling
	// Import(path) is the same as calling ImportFrom(path, "", 0);
	// i.e., locally vendored packages may not be found.
	// The types package does not call Import if an ImporterFrom
	// is present.
	Importer
	// ImportFrom returns the imported package for the given import
	// path when imported by a package file located in dir.
	// If the import failed, besides returning an error, ImportFrom
	// is encouraged to cache and return a package anyway, if one
	// was created. This will reduce package inconsistencies and
	// follow-on type checker errors due to the missing package.
	// The mode value must be 0; it is reserved for future use.
	// Two calls to ImportFrom with the same path and dir must
	// return the same package.
	ImportFrom(path, dir string, mode ImportMode) (*Package, error)
}
type Info struct {
	// Types maps expressions to their types, and for constant
	// expressions, also their values. Invalid expressions are
	// omitted.
	//
	// For (possibly parenthesized) identifiers denoting built-in
	// functions, the recorded signatures are call-site specific:
	// if the call result is not a constant, the recorded type is
	// an argument-specific signature. Otherwise, the recorded type
	// is invalid.
	//
	// The Types map does not record the type of every identifier,
	// only those that appear where an arbitrary expression is
	// permitted. For instance, the identifier f in a selector
	// expression x.f is found only in the Selections map, the
	// identifier z in a variable declaration 'var z int' is found
	// only in the Defs map, and identifiers denoting packages in
	// qualified identifiers are collected in the Uses map.
	Types map[ast.Expr]TypeAndValue
	// Instances maps identifiers denoting generic types or functions to their
	// type arguments and instantiated type.
	//
	// For example, Instances will map the identifier for 'T' in the type
	// instantiation T[int, string] to the type arguments [int, string] and
	// resulting instantiated *Named type. Given a generic function
	// func F[A any](A), Instances will map the identifier for 'F' in the call
	// expression F(int(1)) to the inferred type arguments [int], and resulting
	// instantiated *Signature.
	//
	// Invariant: Instantiating Uses[id].Type() with Instances[id].TypeArgs
	// results in an equivalent of Instances[id].Type.
	Instances map[*ast.Ident]Instance
	// Defs maps identifiers to the objects they define (including
	// package names, dots "." of dot-imports, and blank "_" identifiers).
	// For identifiers that do not denote objects (e.g., the package name
	// in package clauses, or symbolic variables t in t := x.(type) of
	// type switch headers), the corresponding objects are nil.
	//
	// For an embedded field, Defs returns the field *Var it defines.
	//
	// Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()
	Defs map[*ast.Ident]Object
	// Uses maps identifiers to the objects they denote.
	//
	// For an embedded field, Uses returns the *TypeName it denotes.
	//
	// Invariant: Uses[id].Pos() != id.Pos()
	Uses map[*ast.Ident]Object
	// Implicits maps nodes to their implicitly declared objects, if any.
	// The following node and object types may appear:
	//
	//     node               declared object
	//
	//     *ast.ImportSpec    *PkgName for imports without renames
	//     *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)
	//     *ast.Field         anonymous parameter *Var (incl. unnamed results)
	//
	Implicits map[ast.Node]Object
	// Selections maps selector expressions (excluding qualified identifiers)
	// to their corresponding selections.
	Selections map[*ast.SelectorExpr]*Selection
	// Scopes maps ast.Nodes to the scopes they define. Package scopes are not
	// associated with a specific node but with all files belonging to a package.
	// Thus, the package scope can be found in the type-checked Package object.
	// Scopes nest, with the Universe scope being the outermost scope, enclosing
	// the package scope, which contains (one or more) files scopes, which enclose
	// function scopes which in turn enclose statement and function literal scopes.
	// Note that even though package-level functions are declared in the package
	// scope, the function scopes are embedded in the file scope of the file
	// containing the function declaration.
	//
	// The Scope of a function contains the declarations of any
	// type parameters, parameters, and named results, plus any
	// local declarations in the body block.
	// It is coextensive with the complete extent of the
	// function's syntax ([*ast.FuncDecl] or [*ast.FuncLit]).
	// The Scopes mapping does not contain an entry for the
	// function body ([*ast.BlockStmt]); the function's scope is
	// associated with the [*ast.FuncType].
	//
	// The following node types may appear in Scopes:
	//
	//     *ast.File
	//     *ast.FuncType
	//     *ast.TypeSpec
	//     *ast.BlockStmt
	//     *ast.IfStmt
	//     *ast.SwitchStmt
	//     *ast.TypeSwitchStmt
	//     *ast.CaseClause
	//     *ast.CommClause
	//     *ast.ForStmt
	//     *ast.RangeStmt
	//
	Scopes map[ast.Node]*Scope
	// InitOrder is the list of package-level initializers in the order in which
	// they must be executed. Initializers referring to variables related by an
	// initialization dependency appear in topological order, the others appear
	// in source order. Variables without an initialization expression do not
	// appear in this list.
	InitOrder []*Initializer
	// FileVersions maps a file to its Go version string.
	// If the file doesn't specify a version, the reported
	// string is Config.GoVersion.
	// Version strings begin with “go”, like “go1.21”, and
	// are suitable for use with the [go/version] package.
	FileVersions map[*ast.File]string
}
func (info *Info) ObjectOf(id *ast.Ident) Object
func (info *Info) PkgNameOf(imp *ast.ImportSpec) *PkgName
func (info *Info) TypeOf(e ast.Expr) Type
type Initializer struct {
	Lhs []*Var // var Lhs = Rhs
	Rhs ast.Expr
}
func (init *Initializer) String() string
type Instance struct {
	TypeArgs *TypeList
	Type     Type
}
type Interface struct {
	// Has unexported fields.
}
func NewInterface(methods []*Func, embeddeds []*Named) *Interface
func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface
func (t *Interface) Complete() *Interface
func (t *Interface) Embedded(i int) *Named
func (t *Interface) EmbeddedType(i int) Type
func (t *Interface) Empty() bool
func (t *Interface) ExplicitMethod(i int) *Func
func (t *Interface) IsComparable() bool
func (t *Interface) IsImplicit() bool
func (t *Interface) IsMethodSet() bool
func (t *Interface) MarkImplicit()
func (t *Interface) Method(i int) *Func
func (t *Interface) NumEmbeddeds() int
func (t *Interface) NumExplicitMethods() int
func (t *Interface) NumMethods() int
func (t *Interface) String() string
func (t *Interface) Underlying() Type
type Label struct {
	// Has unexported fields.
}
func NewLabel(pos token.Pos, pkg *Package, name string) *Label
func (obj *Label) Exported() bool
func (obj *Label) Id() string
func (obj *Label) Name() string
func (obj *Label) Parent() *Scope
func (obj *Label) Pkg() *Package
func (obj *Label) Pos() token.Pos
func (obj *Label) String() string
func (obj *Label) Type() Type
type Map struct {
	// Has unexported fields.
}
func NewMap(key, elem Type) *Map
func (m *Map) Elem() Type
func (m *Map) Key() Type
func (t *Map) String() string
func (t *Map) Underlying() Type
type MethodSet struct {
	// Has unexported fields.
}
func NewMethodSet(T Type) *MethodSet
func (s *MethodSet) At(i int) *Selection
func (s *MethodSet) Len() int
func (s *MethodSet) Lookup(pkg *Package, name string) *Selection
func (s *MethodSet) String() string
type Named struct {
	// Has unexported fields.
}
func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named
func (t *Named) AddMethod(m *Func)
func (t *Named) Method(i int) *Func
func (t *Named) NumMethods() int
func (t *Named) Obj() *TypeName
func (t *Named) Origin() *Named
func (t *Named) SetTypeParams(tparams []*TypeParam)
func (t *Named) SetUnderlying(underlying Type)
func (t *Named) String() string
func (t *Named) TypeArgs() *TypeList
func (t *Named) TypeParams() *TypeParamList
func (t *Named) Underlying() Type
[underlying type]: https://go.dev/ref/spec#Underlying_types.
type Nil struct {
	// Has unexported fields.
}
func (obj *Nil) Exported() bool
func (obj *Nil) Id() string
func (obj *Nil) Name() string
func (obj *Nil) Parent() *Scope
func (obj *Nil) Pkg() *Package
func (obj *Nil) Pos() token.Pos
func (obj *Nil) String() string
func (obj *Nil) Type() Type
type Object interface {
	Parent() *Scope // scope in which this object is declared; nil for methods and struct fields
	Pos() token.Pos // position of object identifier in declaration
	Pkg() *Package  // package to which this object belongs; nil for labels and objects in the Universe scope
	Name() string   // package local object name
	Type() Type     // object type
	Exported() bool // reports whether the name starts with a capital letter
	Id() string     // object name if exported, qualified name if not exported (see func Id)
	// String returns a human-readable string of the object.
	String() string
	// Has unexported methods.
}
func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)
type Package struct {
	// Has unexported fields.
}
var Unsafe *Package
func NewPackage(path, name string) *Package
func (pkg *Package) Complete() bool
func (pkg *Package) GoVersion() string
func (pkg *Package) Imports() []*Package
func (pkg *Package) MarkComplete()
func (pkg *Package) Name() string
func (pkg *Package) Path() string
func (pkg *Package) Scope() *Scope
func (pkg *Package) SetImports(list []*Package)
func (pkg *Package) SetName(name string)
func (pkg *Package) String() string
type PkgName struct {
	// Has unexported fields.
}
func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName
func (obj *PkgName) Exported() bool
func (obj *PkgName) Id() string
func (obj *PkgName) Imported() *Package
func (obj *PkgName) Name() string
func (obj *PkgName) Parent() *Scope
func (obj *PkgName) Pkg() *Package
func (obj *PkgName) Pos() token.Pos
func (obj *PkgName) String() string
func (obj *PkgName) Type() Type
type Pointer struct {
	// Has unexported fields.
}
func NewPointer(elem Type) *Pointer
func (p *Pointer) Elem() Type
func (p *Pointer) String() string
func (p *Pointer) Underlying() Type
type Qualifier func(*Package) string
func RelativeTo(pkg *Package) Qualifier
type Scope struct {
	// Has unexported fields.
}
var Universe *Scope
func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope
func (s *Scope) Child(i int) *Scope
func (s *Scope) Contains(pos token.Pos) bool
func (s *Scope) End() token.Pos
func (s *Scope) Innermost(pos token.Pos) *Scope
func (s *Scope) Insert(obj Object) Object
func (s *Scope) Len() int
func (s *Scope) Lookup(name string) Object
func (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)
func (s *Scope) Names() []string
func (s *Scope) NumChildren() int
func (s *Scope) Parent() *Scope
func (s *Scope) Pos() token.Pos
func (s *Scope) String() string
func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)
type Selection struct {
	// Has unexported fields.
}
func (s *Selection) Index() []int
func (s *Selection) Indirect() bool
func (s *Selection) Kind() SelectionKind
func (s *Selection) Obj() Object
func (s *Selection) Recv() Type
func (s *Selection) String() string
func (s *Selection) Type() Type
type SelectionKind int
const (
	FieldVal   SelectionKind = iota // x.f is a struct field selector
	MethodVal                       // x.f is a method selector
	MethodExpr                      // x.f is a method expression
)
type Signature struct {
	// Has unexported fields.
}
func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature
func NewSignatureType(recv *Var, recvTypeParams, typeParams []*TypeParam, params, results *Tuple, variadic bool) *Signature
func (s *Signature) Params() *Tuple
func (s *Signature) Recv() *Var
func (s *Signature) RecvTypeParams() *TypeParamList
func (s *Signature) Results() *Tuple
func (t *Signature) String() string
func (s *Signature) TypeParams() *TypeParamList
func (t *Signature) Underlying() Type
func (s *Signature) Variadic() bool
type Sizes interface {
	// Alignof returns the alignment of a variable of type T.
	// Alignof must implement the alignment guarantees required by the spec.
	// The result must be >= 1.
	Alignof(T Type) int64
	// Offsetsof returns the offsets of the given struct fields, in bytes.
	// Offsetsof must implement the offset guarantees required by the spec.
	// A negative entry in the result indicates that the struct is too large.
	Offsetsof(fields []*Var) []int64
	// Sizeof returns the size of a variable of type T.
	// Sizeof must implement the size guarantees required by the spec.
	// A negative result indicates that T is too large.
	Sizeof(T Type) int64
}
func SizesFor(compiler, arch string) Sizes
type Slice struct {
	// Has unexported fields.
}
func NewSlice(elem Type) *Slice
func (s *Slice) Elem() Type
func (s *Slice) String() string
func (s *Slice) Underlying() Type
type StdSizes struct {
	WordSize int64 // word size in bytes - must be >= 4 (32bits)
	MaxAlign int64 // maximum alignment in bytes - must be >= 1
}
func (s *StdSizes) Alignof(T Type) (result int64)
func (s *StdSizes) Offsetsof(fields []*Var) []int64
func (s *StdSizes) Sizeof(T Type) int64
type Struct struct {
	// Has unexported fields.
}
func NewStruct(fields []*Var, tags []string) *Struct
func (s *Struct) Field(i int) *Var
func (s *Struct) NumFields() int
func (t *Struct) String() string
func (s *Struct) Tag(i int) string
func (t *Struct) Underlying() Type
type Term term
func NewTerm(tilde bool, typ Type) *Term
func (t *Term) String() string
func (t *Term) Tilde() bool
func (t *Term) Type() Type
type Tuple struct {
	// Has unexported fields.
}
func NewTuple(x ...*Var) *Tuple
func (t *Tuple) At(i int) *Var
func (t *Tuple) Len() int
func (t *Tuple) String() string
func (t *Tuple) Underlying() Type
type Type interface {
	// Underlying returns the underlying type of a type.
	// Underlying types are never Named, TypeParam, or Alias types.
	//
	// See https://go.dev/ref/spec#Underlying_types.
	Underlying() Type
	// String returns a string representation of a type.
	String() string
}
func Default(t Type) Type
func Instantiate(ctxt *Context, orig Type, targs []Type, validate bool) (Type, error)
func Unalias(t Type) Type
type TypeAndValue struct {
	Type  Type
	Value constant.Value
	// Has unexported fields.
}
func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)
func (tv TypeAndValue) Addressable() bool
func (tv TypeAndValue) Assignable() bool
func (tv TypeAndValue) HasOk() bool
func (tv TypeAndValue) IsBuiltin() bool
func (tv TypeAndValue) IsNil() bool
func (tv TypeAndValue) IsType() bool
func (tv TypeAndValue) IsValue() bool
func (tv TypeAndValue) IsVoid() bool
type TypeList struct {
	// Has unexported fields.
}
func (l *TypeList) At(i int) Type
func (l *TypeList) Len() int
type TypeName struct {
	// Has unexported fields.
}
func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName
func (obj *TypeName) Exported() bool
func (obj *TypeName) Id() string
func (obj *TypeName) IsAlias() bool
func (obj *TypeName) Name() string
func (obj *TypeName) Parent() *Scope
func (obj *TypeName) Pkg() *Package
func (obj *TypeName) Pos() token.Pos
func (obj *TypeName) String() string
func (obj *TypeName) Type() Type
type TypeParam struct {
	// Has unexported fields.
}
func NewTypeParam(obj *TypeName, constraint Type) *TypeParam
func (t *TypeParam) Constraint() Type
func (t *TypeParam) Index() int
func (t *TypeParam) Obj() *TypeName
func (t *TypeParam) SetConstraint(bound Type)
func (t *TypeParam) String() string
func (t *TypeParam) Underlying() Type
[underlying type]: https://go.dev/ref/spec#Underlying_types.
type TypeParamList struct {
	// Has unexported fields.
}
func (l *TypeParamList) At(i int) *TypeParam
func (l *TypeParamList) Len() int
type Union struct {
	// Has unexported fields.
}
func NewUnion(terms []*Term) *Union
func (u *Union) Len() int
func (u *Union) String() string
func (u *Union) Term(i int) *Term
func (u *Union) Underlying() Type
type Var struct {
	// Has unexported fields.
}
func NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var
func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var
func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var
func (obj *Var) Anonymous() bool
func (obj *Var) Embedded() bool
func (obj *Var) Exported() bool
func (obj *Var) Id() string
func (obj *Var) IsField() bool
func (obj *Var) Name() string
func (obj *Var) Origin() *Var
func (obj *Var) Parent() *Scope
func (obj *Var) Pkg() *Package
func (obj *Var) Pos() token.Pos
func (obj *Var) String() string
