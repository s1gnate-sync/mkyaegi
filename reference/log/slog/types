type Attr struct {
	Key   string
	Value Value
}
func Any(key string, value any) Attr
func Bool(key string, v bool) Attr
func Duration(key string, v time.Duration) Attr
func Float64(key string, v float64) Attr
func Group(key string, args ...any) Attr
func Int(key string, value int) Attr
func Int64(key string, value int64) Attr
func String(key, value string) Attr
func Time(key string, v time.Time) Attr
func Uint64(key string, v uint64) Attr
func (a Attr) Equal(b Attr) bool
func (a Attr) String() string
type Handler interface {
	// Enabled reports whether the handler handles records at the given level.
	// The handler ignores records whose level is lower.
	// It is called early, before any arguments are processed,
	// to save effort if the log event should be discarded.
	// If called from a Logger method, the first argument is the context
	// passed to that method, or context.Background() if nil was passed
	// or the method does not take a context.
	// The context is passed so Enabled can use its values
	// to make a decision.
	Enabled(context.Context, Level) bool
	// Handle handles the Record.
	// It will only be called when Enabled returns true.
	// The Context argument is as for Enabled.
	// It is present solely to provide Handlers access to the context's values.
	// Canceling the context should not affect record processing.
	// (Among other things, log messages may be necessary to debug a
	// cancellation-related problem.)
	//
	// Handle methods that produce output should observe the following rules:
	//   - If r.Time is the zero time, ignore the time.
	//   - If r.PC is zero, ignore it.
	//   - Attr's values should be resolved.
	//   - If an Attr's key and value are both the zero value, ignore the Attr.
	//     This can be tested with attr.Equal(Attr{}).
	//   - If a group's key is empty, inline the group's Attrs.
	//   - If a group has no Attrs (even if it has a non-empty key),
	//     ignore it.
	Handle(context.Context, Record) error
	// WithAttrs returns a new Handler whose attributes consist of
	// both the receiver's attributes and the arguments.
	// The Handler owns the slice: it may retain, modify or discard it.
	WithAttrs(attrs []Attr) Handler
	// WithGroup returns a new Handler with the given group appended to
	// the receiver's existing groups.
	// The keys of all subsequent attributes, whether added by With or in a
	// Record, should be qualified by the sequence of group names.
	//
	// How this qualification happens is up to the Handler, so long as
	// this Handler's attribute keys differ from those of another Handler
	// with a different sequence of group names.
	//
	// A Handler should treat WithGroup as starting a Group of Attrs that ends
	// at the end of the log event. That is,
	//
	//     logger.WithGroup("s").LogAttrs(ctx, level, msg, slog.Int("a", 1), slog.Int("b", 2))
	//
	// should behave like
	//
	//     logger.LogAttrs(ctx, level, msg, slog.Group("s", slog.Int("a", 1), slog.Int("b", 2)))
	//
	// If the name is empty, WithGroup returns the receiver.
	WithGroup(name string) Handler
}
type HandlerOptions struct {
	// AddSource causes the handler to compute the source code position
	// of the log statement and add a SourceKey attribute to the output.
	AddSource bool
	// Level reports the minimum record level that will be logged.
	// The handler discards records with lower levels.
	// If Level is nil, the handler assumes LevelInfo.
	// The handler calls Level.Level for each record processed;
	// to adjust the minimum level dynamically, use a LevelVar.
	Level Leveler
	// ReplaceAttr is called to rewrite each non-group attribute before it is logged.
	// The attribute's value has been resolved (see [Value.Resolve]).
	// If ReplaceAttr returns a zero Attr, the attribute is discarded.
	//
	// The built-in attributes with keys "time", "level", "source", and "msg"
	// are passed to this function, except that time is omitted
	// if zero, and source is omitted if AddSource is false.
	//
	// The first argument is a list of currently open groups that contain the
	// Attr. It must not be retained or modified. ReplaceAttr is never called
	// for Group attributes, only their contents. For example, the attribute
	// list
	//
	//     Int("a", 1), Group("g", Int("b", 2)), Int("c", 3)
	//
	// results in consecutive calls to ReplaceAttr with the following arguments:
	//
	//     nil, Int("a", 1)
	//     []string{"g"}, Int("b", 2)
	//     nil, Int("c", 3)
	//
	// ReplaceAttr can be used to change the default keys of the built-in
	// attributes, convert types (for example, to replace a `time.Time` with the
	// integer seconds since the Unix epoch), sanitize personal information, or
	// remove attributes from the output.
	ReplaceAttr func(groups []string, a Attr) Attr
}
type JSONHandler struct {
	// Has unexported fields.
}
func NewJSONHandler(w io.Writer, opts *HandlerOptions) *JSONHandler
func (h *JSONHandler) Enabled(_ context.Context, level Level) bool
func (h *JSONHandler) Handle(_ context.Context, r Record) error
func (h *JSONHandler) WithAttrs(attrs []Attr) Handler
func (h *JSONHandler) WithGroup(name string) Handler
type Kind int
const (
	KindAny Kind = iota
	KindBool
	KindDuration
	KindFloat64
	KindInt64
	KindString
	KindTime
	KindUint64
	KindGroup
	KindLogValuer
)
func (k Kind) String() string
type Level int
const (
	LevelDebug Level = -4
	LevelInfo  Level = 0
	LevelWarn  Level = 4
	LevelError Level = 8
)
func SetLogLoggerLevel(level Level) (oldLevel Level)
func (l Level) Level() Level
func (l Level) MarshalJSON() ([]byte, error)
func (l Level) MarshalText() ([]byte, error)
func (l Level) String() string
func (l *Level) UnmarshalJSON(data []byte) error
func (l *Level) UnmarshalText(data []byte) error
type LevelVar struct {
	// Has unexported fields.
}
func (v *LevelVar) Level() Level
func (v *LevelVar) MarshalText() ([]byte, error)
func (v *LevelVar) Set(l Level)
func (v *LevelVar) String() string
func (v *LevelVar) UnmarshalText(data []byte) error
type Leveler interface {
	Level() Level
}
type LogValuer interface {
	LogValue() Value
}
type Logger struct {
	// Has unexported fields.
}
func Default() *Logger
func New(h Handler) *Logger
func With(args ...any) *Logger
func (l *Logger) Debug(msg string, args ...any)
func (l *Logger) DebugContext(ctx context.Context, msg string, args ...any)
func (l *Logger) Enabled(ctx context.Context, level Level) bool
func (l *Logger) Error(msg string, args ...any)
func (l *Logger) ErrorContext(ctx context.Context, msg string, args ...any)
func (l *Logger) Handler() Handler
func (l *Logger) Info(msg string, args ...any)
func (l *Logger) InfoContext(ctx context.Context, msg string, args ...any)
func (l *Logger) Log(ctx context.Context, level Level, msg string, args ...any)
func (l *Logger) LogAttrs(ctx context.Context, level Level, msg string, attrs ...Attr)
func (l *Logger) Warn(msg string, args ...any)
func (l *Logger) WarnContext(ctx context.Context, msg string, args ...any)
func (l *Logger) With(args ...any) *Logger
func (l *Logger) WithGroup(name string) *Logger
type Record struct {
	// The time at which the output method (Log, Info, etc.) was called.
	Time time.Time
	// The log message.
	Message string
	// The level of the event.
	Level Level
	// The program counter at the time the record was constructed, as determined
	// by runtime.Callers. If zero, no program counter is available.
	//
	// The only valid use for this value is as an argument to
	// [runtime.CallersFrames]. In particular, it must not be passed to
	// [runtime.FuncForPC].
	PC uintptr
	// Has unexported fields.
}
func NewRecord(t time.Time, level Level, msg string, pc uintptr) Record
func (r *Record) Add(args ...any)
func (r *Record) AddAttrs(attrs ...Attr)
func (r Record) Attrs(f func(Attr) bool)
func (r Record) Clone() Record
func (r Record) NumAttrs() int
type Source struct {
	// Function is the package path-qualified function name containing the
	// source line. If non-empty, this string uniquely identifies a single
	// function in the program. This may be the empty string if not known.
	Function string `json:"function"`
	// File and Line are the file name and line number (1-based) of the source
	// line. These may be the empty string and zero, respectively, if not known.
	File string `json:"file"`
	Line int    `json:"line"`
}
type TextHandler struct {
	// Has unexported fields.
}
func NewTextHandler(w io.Writer, opts *HandlerOptions) *TextHandler
func (h *TextHandler) Enabled(_ context.Context, level Level) bool
func (h *TextHandler) Handle(_ context.Context, r Record) error
func (h *TextHandler) WithAttrs(attrs []Attr) Handler
func (h *TextHandler) WithGroup(name string) Handler
type Value struct {
	// Has unexported fields.
}
func AnyValue(v any) Value
func BoolValue(v bool) Value
func DurationValue(v time.Duration) Value
func Float64Value(v float64) Value
func GroupValue(as ...Attr) Value
func Int64Value(v int64) Value
func IntValue(v int) Value
func StringValue(value string) Value
func TimeValue(v time.Time) Value
func Uint64Value(v uint64) Value
func (v Value) Any() any
func (v Value) Bool() bool
func (v Value) Duration() time.Duration
func (v Value) Equal(w Value) bool
func (v Value) Float64() float64
func (v Value) Group() []Attr
func (v Value) Int64() int64
func (v Value) Kind() Kind
func (v Value) LogValuer() LogValuer
func (v Value) Resolve() (rv Value)
func (v Value) String() string
func (v Value) Time() time.Time
